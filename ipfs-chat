#!/usr/bin/env bash
# Details: See info and usage functions below
# Warning: This code closes all background processes in the current terminal session on exit # TODO:

export version="0.1.0 (alpha)"

info(){
  # Brief: Info about ipfs-chat
  echo -n "
                        Welcome to ipfs-chat
                        ====================
Repo (For details & Bug-report): https://github.com/SomajitDey/ipfs-chat
License: GNU GPL v3-or-later (C) 2021 Somajit Dey
Version: " >&2
  echo "${version}"
}; export -f info

usage(){
  # Brief: Show help and exit
  echo -e "\nUsage: ipfs-chat [-n <nick>] [-r <room>] [-d <file-download-dir>] [-c <ipfs-repo-path>] [-o <chat-log-path>] [-w | -l]"
  echo -e "\nNote: -w or -W implies WAN-only connection; -l|-L is LAN-only; To have both WAN & LAN, don't use any of these flags"
  echo -e "\nVersion: ipfs-chat -v"
  echo -e "\nGenerate random room name: ipfs-chat -g"
  echo ; exit 1
} >&2; export -f usage

hmac(){
  # Usage: hmac <salt> <string>
  # Output: base64
  sha1(){ sha1sum < <(echo -n "${1}") | cut -d ' ' -f 1;} # Usage: sha1 <string>
  local key="$(sha1 "${1}")" data="$(sha1 "${2}")"
  echo -n "${data}" | xxd -r -p | openssl dgst -sha1 -mac hmac -macopt hexkey:"${key}" | cut -d ' ' -f 2 | \
    xxd -r -p | base64 -w0 | tr -d = # Deleting last = because base64 encoding 160-bit hmac always gives single =
}; export -f hmac

dep_check(){
  # Brief: Check major dependencies
  local ipfs_version quit
  if ipfs_version=$(ipfs version --number 2>/dev/null); then
    [[ "${ipfs_version}" > 0.9.0 ]] || \
    { echo -e "Required: go-ipfs version > 0.9.0\nSuggestion: ipfs update install latest\n"; quit="yes";}
  else
    echo -e "Required: go-ipfs\nSource: https://docs.ipfs.io/install/command-line/#linux\n"
    quit="yes"
  fi
  if ! command -v dialog &>/dev/null; then
    echo -e "Required: dialog\nSource: Native package repository\n"
    quit="yes"
  fi
  if ! command -v setsid &>/dev/null; then
    echo -e "Required: setsid\nSource: Native package repository\n"
    quit="yes"
  fi
  [[ -v quit ]] && exit 1
} >&2; export -f dep_check

parse_cmdline(){
  local opt OPTIND=1
  while getopts n:r:d:c:gwWlLo:vbh opt;do
    case "${opt}" in
      n) nick="${OPTARG}";;
      r) room="${OPTARG}";;
      d) dldir="${OPTARG}";;
      c) local repo="${OPTARG}";;
      g) echo -n "Random room: " >&2; dd if=/dev/urandom count=1 bs=6 2>/dev/null | base64; exit;;
      w|W) export connect_mode="WAN";;
      l|L) export connect_mode="LAN";;
      o) export chat="${OPTARG}";;
      v) echo "${version}"; exit;;
      b) export disable_bandwidth_metrics="false";;
      h|*) usage;;
    esac
  done
  export room="${room:="salon"}" nick="${nick:="${USER}"}" dldir="${dldir:="${HOME}/ipfs-chat-downloads"}"
  export IPFS_PATH="${repo:-"${HOME}/.ipfs-chat"}"
}; export -f parse_cmdline

parse_cmdline "$@"

info

ipfs_config(){
  # Brief: Configure IPFS node
  # Note: Use random ports for everything so that multiple IPFS nodes can coexist on the same machine
  # Note: Most configs below are for reducing bandwidth and CPU usage
  echo -ne "Status: Configuring IPFS node...\r"
  if ! ipfs id &>/dev/null; then
    (ipfs init --profile lowpower && ipfs config profile apply randomports) >/dev/null || \
      { echo "Error: Failed to create IPFS repo at ${IPFS_PATH}"; exit 1;}
    ipfs config Pubsub.Router gossipsub
    ipfs config Ipns.RepublishPeriod 2m0s
    ipfs config Ipns.RecordLifetime 24h
    ipfs config Reprovider.Interval 2m0s
    ipfs config Reprovider.Strategy roots
    ipfs config Routing.Type dhtclient
    ipfs config Swarm.ConnMgr.Type none
    ipfs config --bool Swarm.EnableRelayHop false
  fi

  export sess_peers="${IPFS_PATH}/session_peers" # This file caches all ipfs-chat peers (multiaddresses) seen when node is online
  
  # Repo cleanup when no other instance is running; i.e. node is offline
  if ! ipfs swarm peers; then
    rm -f "${sess_peers}"
    ipfs pin ls --type all | cut -d' ' -f1 | xargs -n1 ipfs pin rm
    ipfs repo gc
  fi &>/dev/null
  
  ipfs config --bool Swarm.DisableBandwidthMetrics "${disable_bandwidth_metrics:-true}"

  case "${connect_mode}" in
    LAN)
      ipfs config --bool Discovery.MDNS.Enabled true
      ipfs bootstrap rm all &>/dev/null # For faster startup
      # Disable NAT traversal
      ipfs config --bool Swarm.DisableNatPortMap true
      ipfs config --bool Swarm.Transports.Network.Relay false
      # ipfs config --bool Swarm.DisableRelay true
      ipfs config --bool Swarm.EnableAutoRelay false
      ;;
    WAN | *)
      if [[ "${connect_mode}" == WAN ]]; then
        ipfs config --bool Discovery.MDNS.Enabled false
      else
        ipfs config --bool Discovery.MDNS.Enabled true
      fi
      ipfs bootstrap add default &>/dev/null # For WAN-DHT
      # For NAT traversal
      ipfs config --bool Swarm.DisableNatPortMap false
      ipfs config --bool Swarm.Transports.Network.Relay true
      # ipfs config --bool Swarm.DisableRelay false
      ipfs config --bool Swarm.EnableAutoRelay true
      ;;
  esac

  pscan(){
    # Brief: Give an unused, random, local TCP port except the one passed as argument
    command -v nc &>/dev/null || return 1 # TODO: For machines with no nc consider socat
    local port except="${1}"
    for port in $(seq 49152 65535 | tac);do
      ((port!=except)) || continue
      ! nc -z localhost "${port}" && echo "${port}" && return # TODO: For machines with no nc consider socat
    done
  } 2>/dev/null; export -f pscan
  local API_port="$(pscan)"; ipfs config Addresses.API "/ip4/127.0.0.1/tcp/${API_port:=5001}"
  local gateway_port="$(pscan "${API_port}")"; ipfs config Addresses.Gateway "/ip4/127.0.0.1/tcp/${gateway_port:=8080}"

  until ipfs swarm peers;do
    setsid --fork ipfs daemon --enable-pubsub-experiment --enable-namesys-pubsub
    # setsid makes sure daemon runs in a separate session, such that `pkill -s 0` does not kill it.
    sleep 0.1
  done &>/dev/null
  echo "Status: IPFS node is configured"
  
  export selfID="$(ipfs config Identity.PeerID)"
  export topic="$(hmac "ipfs-chat" "${room}")" broadcast="$(hmac "peer-addresses" "${room}")"
} >&2; export -f ipfs_config

ipfs_config

config(){
  # Brief: General config. Compute and export variables. Setup tmp dir and runtime filesystem.
  if ls -d "${IPFS_PATH}/room#"* &>/dev/null; then
    export nick="$(tail -n1 $(ls -d1 "${IPFS_PATH}/room#"* | head -n1)/pubkey.asc)"
    echo "Note: Using ${nick} as nick" # Using separate nicks with same peer ID will cause conflicts with IPNS
  fi

  export enc_key="$(hmac "symmetric-encryption-key" "${room}")" tmpdir="${IPFS_PATH}/room#${topic}"
  mkdir "${tmpdir}" 2>/dev/null || { echo "Error: Another instance running"; exit 1;}
  tmpgen(){ mktemp "${tmpdir}/.XXXXX";}; export -f tmpgen

  export chat="${chat:-"${tmpdir}/chat"}" peers="${tmpdir}/peers" input="${tmpdir}/input"
  :>"${chat}"; echo "Discovering...">"${peers}"; :>"${input}" # Clear files: Redirected no-op

  export cb_wd="${tmpdir}/chatbox.width" # Chatbox width
  lwrap(){
    # Brief: Line wrapping to fit our chatbox width
    # Usage: lwrap [file]
    # Note: If file is provided, file is folded in-place under lock. Otherwise, stdin to stdout
    local file="${1}" width="$(($(flock -s "${cb_wd}" cat "${cb_wd}")-5))" # Read lock; note option -s in flock
    if [[ -n "${file}" ]]; then
      local buff="$(tmpgen)"
      fold -w "${width}" "${file}" > "${buff}" && flock "${file}" mv "${buff}" "${file}" # In-place, atomic edit
    else
      fold -w "${width}"
    fi
  }; export -f lwrap
  
  trap "trap '' TERM; pkill -s 0; rm -rf ${tmpdir}; ls -d ${IPFS_PATH}/room#* &>/dev/null || ipfs shutdown" exit # TODO: Replace pkill -s 0 with smthing better
} >&2; export -f config

config

identity(){
  # Brief: Generate key-pair. Claim nick & pubkey using IPNS.
  export GNUPGHOME="${IPFS_PATH}/gpg" pubkey="${tmpdir}/pubkey.asc" peer_kbx="${tmpdir}/peer.kbx"
  gnupg(){ flock "${GNUPGHOME}" gpg --batch -q --always-trust "${@}";}; export -f gnupg # Thread-safe gpg in batch mode
  if mkdir "${GNUPGHOME}"; then
    gnupg --gen-key << EOF
  %no-protection
  Key-Type: EDDSA
    Key-Curve: ed25519
  Subkey-Type: ECDH
    Subkey-Curve: cv25519
  Name-Real: ${selfID}
  Expire-Date: 0
EOF
    (($? == 0)) || return 1
    gnupg -a -o "${GNUPGHOME}/pubkey.asc" --export "${selfID}"
  fi
  cat "${GNUPGHOME}/pubkey.asc" <(echo "${nick}") > "${pubkey}"
  ipfs name publish --allow-offline --ipns-base=b58mh "/ipfs/$(ipfs add -Q "${pubkey}")" & # Claim nick & pubkey using IPNS
} &>/dev/null; export -f identity

identity || { echo "Error: Failed to generate key-pair" >&2; exit 1;}

cache_peer(){
  # Brief: Cache peerID or multiaddress given as argument. The cache will be used by con_cull
  local peerID="${1}"
  grep -q "${peerID}" "${sess_peers}" || flock "${sess_peers}" echo "${peerID}" >> "${sess_peers}"
} &>/dev/null; export -f cache_peer

connect_peer(){
  # Brief: Connect to peer ID provided as argument
  local peerID="${1}" multiaddress
  [[ "${peerID}" != "${selfID}" ]] || return 1
  ipfs swarm connect "/p2p/${peerID}" || return 1
  for multiaddress in $(ipfs swarm peers | grep "${peerID}"); do
    cache_peer "${multiaddress}"
  done
} &>/dev/null; export -f connect_peer

peer_pubkey_nick(){
  # Brief: Import pubkey of peer ID passed as argument and output its nick. Flag -n to force IPNS update (nocache).
  # TODO: TBD: peer_pubkey=CID_peerID
  local OPTIND=1 opt nocache
  getopts n opt; [[ "${opt}" == "n" ]] && nocache="--nocache"
  local peerID="${!OPTIND}"
  connect_peer "${peerID}" & # Non-blocking
  local ipfs_path="$(i=0; until ipfs name resolve ${nocache} "/ipns/${peerID}" || ((i>5));do ((i++)); done)"
  [[ -n "${ipfs_path}" ]] || return 1
  local peer_pubkey="${tmpdir}/${ipfs_path##*/}"
  if ! [[ -e "${peer_pubkey}" ]]; then
    # Check size of file before download to avoid spam. Pubkey is 669 bytes to be exact. Add some grace for nick etc.
    (("$(ipfs files stat --size "${ipfs_path}" || 1001)" < 1000)) || return 1
    gnupg --yes --no-default-keyring --keyring "${peer_kbx}" --delete-keys "${peerID}"
    flock "${peer_pubkey}" ipfs get -o "${peer_pubkey}" "${ipfs_path}" && \
    gnupg --no-default-keyring --keyring "${peer_kbx}" --import "${peer_pubkey}" || rm -f "${peer_pubkey}"
  fi &>/dev/null
  tail -n1 "${peer_pubkey}"
} 2>/dev/null ; export -f peer_pubkey_nick

subscriber_daemon(){
  # Brief: Listen to messages at pubsub, decrypt & verify signature, display if ok
  # TODO: Malicious peer detection and blocking.
  local timestamp CID peerID readbuff recipID sender buffer="$(tmpgen)" gpg_stderr="$(tmpgen)" prefix
  while read -r peerID readbuff recipID;do
    cache_peer "${peerID}"
    (sender="$(peer_pubkey_nick "${peerID}")" || exit 1 # Note absence of -n flag in peer_pubkey_nick
    case "${recipID}" in
      all) 
        prefix="$(printf '=%.0s' {1..40})"$'\n'
        gnupg --keyring "${peer_kbx}" --passphrase "${enc_key}" --pinentry-mode loopback -d
        ;;
      "${selfID}")
        prefix='**************Private message***********'$'\n'
        gnupg --keyring "${peer_kbx}" -d
        ;;
      *) exit 1;;
    esac < <(echo -n "${readbuff}" | base64 -d) > "${buffer}" 2> "${gpg_stderr}" || exit 1
    grep -iq "Good signature from \"${peerID}\"" "${gpg_stderr}" || exit 1 # Verify authenticity/signature
    grep -xq '[[:print:]]*' "${buffer}" || exit 1 # Check msg is text only to avoid spam
    read timestamp CID < <(head -n1 "${buffer}" | grep -xE '[[:digit:]]*([[:blank:]][[:alnum:]]*)?')
    timestamp="$(date -d @${timestamp} +"%a %H:%M:%S")" || exit 1
    prefix="${prefix}${sender} @${peerID:${#peerID}-6:6} ${timestamp} -- "
    flock "${chat}" cat <(echo -n "${prefix}") <(tail -n+2 "${buffer}") <(echo -e \\n) | lwrap >> "${chat}")&
  done < <(ipfs pubsub sub "${topic}" | grep --line-buffered -x '[[:alnum:]]*[[:blank:]][[:alnum:]+/=]*[[:blank:]][[:alnum:]]*')
} &>"${tmpdir}/subscriber_daemon.log"; export -f subscriber_daemon

subscriber_daemon &

pubsub_conn(){
  # Brief: Connect to multiaddresses that are broadcast over pubsub
  local multiaddress peerID
  while read -r multiaddress;do
    peerID="${multiaddress##*/}"
    cache_peer "${multiaddress}"
    [[ "${peerID}" == "${selfID}" ]] || (ipfs swarm peers | grep -q "${peerID}") || ipfs swarm connect "${multiaddress}"
    # TODO: TBD: & (bg) or not?
  done < <(ipfs pubsub sub "${broadcast}" | grep --line-buffered -x '[[:alnum:]/.:-]*')
} &>"${tmpdir}/pubsub_conn.log"; export -f pubsub_conn

pubsub_conn &

con_cull(){
  # Brief: Cull all connections except those in the file provided as argument or cache, & the connection to relay (if any)
  # Purpose: Reducing bandwidth usage by killing all irrelevant connections
  local curr_self_address="$(ipfs id "${selfID}" -f="<addrs>\n")" peerID_list="${1:-"${sess_peers}"}"
  local multiaddress peerID
  for multiaddress in $(ipfs swarm peers); do
    peerID="${multiaddress##*/}"
    grep -q "${peerID}" "${peerID_list}" || (echo "${curr_self_address}" | grep -q "${peerID}") || \
      ipfs swarm disconnect "/p2p/${peerID}" &>/dev/null
  done
} &>/dev/null; export -f con_cull

peering_daemon(){
  # Brief: Discover & connect to chat-peers & announce self for others to discover - at regular intervals
  local peerID peer_nick peerID_list="$(tmpgen)" buffer="$(tmpgen)"
  local interval=30
  while ipfs swarm peers &>/dev/null;do # Do as long as IPFS daemon is alive
    local dht_ops_pid=() # Stores pid's of background DHT operations executing in the current pass
    local timestamp="${EPOCHSECONDS}"
    ipfs pubsub pub "${broadcast}" "$(ipfs id "${selfID}" -f="<addrs>\n")" & # Announce own multiaddresses
    local nonce="$(hmac "${room}" "$((timestamp/120))" | ipfs add -Q --pin=false)" # Announce time based nonce
    sort -u <(ipfs pubsub peers "${topic}") <(timeout 5 ipfs dht findprovs "${nonce}") > "${peerID_list}" # Peer discovery. TODO: Need a slower one?
    for peerID in $(cat "${peerID_list}"); do # Connecting to peers and importing their pubkeys
      (cache_peer "${peerID}"
      peer_nick="$(peer_pubkey_nick -n "${peerID}")" && \
        flock "${buffer}" echo "${peer_nick} @${peerID:${#peerID}-6:6}" >> "${buffer}")& # Non-blocking. Notice the nocache flag -n forcing IPNS update
      local dht_ops_pid+=($!)
    done
    wait ${dht_ops_pid[@]} # Wait till all DHT operations are complete
    sort -o "${buffer}" "${buffer}" && mv "${buffer}" "${peers}" # In-place sort followed by atomic move
    con_cull # Need for DHT is over for now. So, let's cull unnecessary connections to reduce bandwidth usage.
    sleep "$((interval-EPOCHSECONDS+timestamp))" #2>/dev/null # Redirection for when the sleep time is negative
  done  
} &>"${tmpdir}/peering_daemon.log"; export -f peering_daemon

peering_daemon &

send(){
  # Brief: Encrypt and sign user's msg & publish to pubsub
  [[ -s "${input}" ]] || return # Skip empty input
  local msg="$(tmpgen)" recipID="all"
  local first_word="$(cut -z -d ' ' -f 1 "${input}")"
  if [[ "${first_word}" =~ ^@[[:alnum:]]{6}$ ]]; then
    recipID="$(grep -Eom1 "[[:alnum:]]*${first_word//@/}$" "${sess_peers}")"
    cut -z -d ' ' -f 2- "${input}" > "${msg}"
    grep -xq "${first_word}" "${msg}" && return # Skip empty input
    local prefix="PM to $(grep "${first_word}" "${peers}") $(date +"%a %H:%M:%S") -- "
    flock "${chat}" cat <(echo -n "${prefix}") "${msg}" <(echo -e \\n) | lwrap >> "${chat}"
  elif [[ -f "${first_word}" ]]; then
    : # TODO: Add WSL support
  else  
    mv "${input}" "${msg}"
  fi
  (local buffer="$(cat <(echo "${EPOCHSECONDS}") "${msg}" | \
    case "${recipID}" in
      all) gnupg --passphrase "${enc_key}" --pinentry-mode loopback -s -c --cipher-algo AES128;;
      *) peer_pubkey_nick "${recipID}" >/dev/null ; gnupg --keyring "${peer_kbx}" -s -r "${recipID}" -e;;
    esac | base64 -w0)"
  ipfs pubsub pub "${topic}" "${selfID} ${buffer} ${recipID}"$'\n') &
} &>/dev/null; export -f send

ui(){
  # Brief: UI event-loop. Window numbering: 1(Top Left) 2(Top Right) 3(Spanning Bottom)
  while :;do
    # Dimensions are computed just before calling `dialog` to accomodate for the latest terminal window size changes
    local tty_height="$(tput lines)" tty_width="$(tput cols)"
    local win3_height=10 win3_width="${tty_width}"
    local win12_height="$((tty_height-win3_height-1))" # The -1 gap looks awesome as it demarcates better
    local win2_width="$((tty_width/4))"
    local win1_width="$((tty_width-win2_width))"
    if ((win1_width != last_win1_width)); then
      flock -x "${cb_wd}" echo "${win1_width}" > "${cb_wd}" # Write lock; note option -x in flock
      lwrap "${chat}"
      local last_win1_width="${win1_width}"
    fi # Conditionality decreases lag between pressing Send and subsequent chatbox update
    local input_help="\Zb\Z4Nick: \Zu\Z0${nick}\Zn \Zb\Z4peerID: \Zu\Z0@${selfID:${#selfID}-6:6}\Zn
\Zb\Z4General-Message:\Z1 Simply type in your text & press Enter or Send\Zn
\Zb\Z4Fle-sharing:\Z2 Drag-n-drop file or type in its path\Zn
\Zb\Z4Private-Message:\Z5 Put recipient's @peerID followed by a space before your text or file-path\Zn"
    dialog --keep-tite \
      --title "ipfs-chat-room: ${room}" --begin 0 0 --tailboxbg "${chat}" "${win12_height}" "${win1_width}" \
      --and-widget \
      --title "online-peers" --begin 0 "${win1_width}" --tailboxbg "${peers}" "${win12_height}" "${win2_width}" \
      --and-widget --colors \
      --no-shadow --title "Press Esc to exit" --begin "$((tty_height-win3_height))" 0 \
      --ok-label "Send" --cancel-label "Clear" \
      --extra-button --extra-label "Inspect chat" \
      --help-button --help-label "Inspect peers" \
      --inputbox "${input_help}" "${win3_height}" "${win3_width}" \
      2> "${input}"
      local exit_code=$?
      case "${exit_code}" in
        0) send ;; # Button: Send
        1) continue ;; # Button: Clear
        2) # Button: Inspect peers
           dialog --keep-tite --no-shadow --exit-label "Back"\
           --title "online-peers" --begin 0 0 --textbox "${peers}" "${tty_height}" "${tty_width}"
           ;;
        3) # Button: Inspect chat
           dialog --keep-tite --no-shadow --exit-label "Back"\
           --title "ipfs-chat-room: ${room}" --begin 0 0 --textbox "${chat}" "${tty_height}" "${tty_width}"
           ;;
        *) return "${exit_code}";; # Esc
      esac
  done
}; export -f ui

echo "Status: Launching UI...(If it takes a long time to open, try pressing Enter)" >&2; ui

[[ -v disable_bandwidth_metrics ]] && echo "Stats: $(ipfs stats bw | head -n3)" >&2

echo "Status: Exiting..." >&2

exit
